package com.algorithm._00_알고리즘_구현.youtube1;

/*
투포인터
- 각 원소마다 모든 값을 순회해야할때, O(N^2)
- 연속하다는 특성을 이용해서 처리, O(N)
(예시)
만약 1, 2, 3, 4, 5 중에 연속하는 3개의 연속한 숫자 중 가장 큰걸 구해라.
1,2,3
2,3,4
3,4,5

for 문을 사용하면 O(N x K)다.
(for 문으로 1, 2, 3, 4, 5 (N개)를 돌면서 K개를 더해줘야한다.)

투포인트 방식을 사용하면?
1, 2, 3
1을 빼주고 4를 더해두면 -> 2, 3, 4
2를 빼주고 5를 더해주면 -> 3, 4, 5

1, 2, 3 일때 1개의 포인터는 1, 다른 1개의 포인터는 3 으로 두고 이 포인터를 움직여서 해결할 수 있다.

처음부터 투포인터를 생각하기가 어렵다.
쉬운 방법부터 생각해봐야한다.
모든 값을 일일이 다 계산해보고, 연속하다는 특징을 사용해볼 수 있는지? 그때 투포인터를 사용해보자.

- 두개의 포인터(커서)가 움직이면서 계산
- 처음부터 생각하기가 어려워서 쉬운 방법부터 생각해야한다.

[팁]
- 처음부터 생각하기 어려우므로 쉬운 방법부터 생각
  -> O(N^2) 시간복잡도 초과한다면
  -> 연속하다는 특징을 활용할 수 있는지 확인
- for 내부 투포인터 계산하는 값의 최대값 확인 필수 (int 초과할지)
- 투포인터 문제 종류
  -> 두개 다 왼쪽에서 / 각각 왼쪽, 오른쪽 / 다른 배열
  -> 일반 O(N) / 정렬 후 투포인터 : O(NlgN)

[예시문제]
백준 2559 - 수열

- 처음 아이디어
: for 문으로 각 수자의 위치에서 이후 K개의 수를 더해서 최대값을 갱신한다.
: for문 : O(N)
: 각 위치에서 K개의 값 더함 : O(K)
: 총 O(N x K)

- 아이디어
: 처음에 K 개의 값을 구한다.
: for문 : 다음 인덱스의 값을 더하고, 앞의 값을 뺀다.
: 이때 최댓값을 갱신한다.
: 시간복잡도 O(N) : 숫자의 개수만큼

- 자료구조
전체 정수 배열 : int[] (수 모두 -100 ~ 100은 INT 가능)
합한 수(K개) : int (100 * 1e5 = 1e7 은 INT 가능)

*/
public class _05_투포인터 {
}
