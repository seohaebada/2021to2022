synchronized로 동기화해서 공유 데이터를 보호하는 것 까지는 좋은데, 특정 쓰레드가 객체의 락을 가진 상태로
오랜시간을 보내지 않도록 하는것도 중요하다.
동기화된 임계영역의 코드를 수행하다가 작업을 더이상 진행할 상황이 아니라면, 
1) wait()
위 메서드를 호출하여 쓰레드가 락을 반납하고 기다리게한다. 그러면 다른 쓰레드가 락을 얻어 해당 객체에 대한 작업을 수행할 수 있게된다.
- 오래 기다린 쓰레드가 락을 얻는다는 보장은 없다. wait()이 호출되면, 실행중이던 쓰레드는 해당 객체의 대기실(waiting pool)에서 통지를 기다린다. 
- notifyAll()은 기다리고 있는 모든 쓰레드에게 통보를 하지만, 그래도 lock을 얻을 수 있는 것은 하나의 쓰레드일 뿐이고,
나머지 쓰레드는 통보를 받긴 했지만, lock을 얻지 못하면 다시 lokc을 기다리는 신세가 된다.
waiting pool은 객체마다 존재하는 것이다. notifyAll()이 호출된다고 해서 모든 객체의 waiting pool에 있는 쓰레드가 깨워지는 것은 아니다.
notifyAll()이 호출된 객체의 waiting pool에 대기중인 쓰레드만 해당된다는 것을 기억하자.

2) notify()
나중에 작업을 진행할 수 있는 상황이 되면 notify()를 호출해서, 작업을 중단했던 쓰레드가 다시 락을 얻어 작업을 진행할 수 있게 한다.

위 두 메서드 모두 Object 클래스에 정의되어있다. 

